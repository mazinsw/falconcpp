unit ExporterRTF;

interface

uses
  Classes, StyleExporter, SysUtils, DScintilla;

type
  TExporterRTF = class(TStyleExporter)
  private
    FBuilder: TStringBuilder;
  protected
    function GetDefaultFilter: string; override;
  public
    constructor Create;
    destructor Destroy; override;
    procedure ExportAll(Editor: TDScintilla); override;
    procedure SaveToStream(Stream: TStream; Encoding: TEncoding); override;
    procedure Clear; override;
  end;

implementation

uses
  Windows, DScintillaTypes, Graphics;

{ TExporterRTF }

procedure TExporterRTF.Clear;
begin
  FBuilder.Clear;
end;

constructor TExporterRTF.Create;
begin
  FBuilder := TStringBuilder.Create;
end;

destructor TExporterRTF.Destroy;
begin
  FBuilder.Free;
  inherited;
end;

function ColorToRTF(AColor: TColor): string;
var
  Col: Cardinal;
begin
  Col := AColor;
  {*****************}
  Result := Format('\red%d\green%d\blue%d;', [(Col shr 0) and $FF,
    (Col shr 8) and $FF,
    (Col shr 16) and $FF]);
end;

procedure TExporterRTF.ExportAll(Editor: TDScintilla);
var
  DocLen, Style, LastStyle, I, J, FontIndex, ColorIndex: Integer;
  UC: Cardinal;
  C, C2, C3: Byte;
  StyleUsed: array[0..STYLE_MAX] of Boolean;
  StyleFonts: TStrings;
  StyleFontIndex: array[0..STYLE_MAX] of Integer;
  StyleColors: TStrings;
  StyleColorFgIndex: array[0..STYLE_MAX] of Integer;
  StyleColorBgIndex: array[0..STYLE_MAX] of Integer;
  Ch: Char;
  BckCl: TColor;
  RTFColor: string;
begin
  Clear;
  DocLen := Editor.GetLength;
  Editor.Colourise(0, -1); // force apply styles
  FBuilder.AppendLine('{\rtf1\ansi\deff0\deftab720');
  for I := 0 to STYLE_MAX do
  begin
    StyleUsed[I] := False;
    StyleColorBgIndex[I] := -1;
  end;
  ColorIndex := 0;
  FontIndex := 0;
  StyleFonts := TStringList.Create;
  StyleColors := TStringList.Create;
  LastStyle := -1;
  for I := 0 to STYLE_MAX do
  begin
    Style := I;
    if StyleUsed[Style] then
      Continue;
    StyleUsed[Style] := True;
    if (LastStyle = -1) or (Editor.StyleGetFont(Style) <>
      Editor.StyleGetFont(LastStyle)) then
    begin
      StyleFonts.Add(Format('{\f%d %s;}', [FontIndex,
        Editor.StyleGetFont(Style)]));
      StyleFontIndex[Style] := FontIndex;
      Inc(FontIndex);
    end
    else
      StyleFontIndex[Style] := StyleFontIndex[LastStyle];
    RTFColor := ColorToRTF(Editor.StyleGetFore(Style));
    J := StyleColors.IndexOf(RTFColor);
    if J = -1 then
    begin
      StyleColors.Add(RTFColor);
      StyleColorFgIndex[Style] := ColorIndex;
      Inc(ColorIndex);
    end
    else
      StyleColorFgIndex[Style] := J;
    BckCl := Editor.StyleGetBack(Style);
    if (BckCl <> clNone) and (BckCl <> clWhite) then
    begin
      RTFColor := ColorToRTF(BckCl);
      J := StyleColors.IndexOf(RTFColor);
      if J = -1 then
      begin
        StyleColors.Add(RTFColor);
        StyleColorBgIndex[Style] := ColorIndex;
        Inc(ColorIndex);
      end
      else
        StyleColorBgIndex[Style] := J;
    end;
    LastStyle := Style;
  end;
  FBuilder.AppendLine('{\fonttbl');
  for I := 0 to StyleFonts.Count - 1 do
  begin
    FBuilder.Append(StyleFonts[I]);
  end;
  FBuilder.AppendLine('}');
  StyleFonts.Free;
  FBuilder.AppendLine('{\colortbl');
  for I := 0 to StyleColors.Count - 1 do
  begin
    FBuilder.Append(StyleColors[I]);
  end;
  FBuilder.AppendLine('}');
  StyleColors.Free;
  FBuilder.AppendLine('{\info{\comment Generated by the Falcon C++ RTF exporter}');
  FBuilder.AppendLine('{\title ' + Title + '}}');
  FBuilder.AppendLine('\deflang1033\pard\plain ');
  LastStyle := -1;
  I := 0;
  while I < DocLen do
  begin
    C := Editor.GetCharAt(I);
    Ch := Char(C);
    Style := Editor.GetStyleAt(I);
    if Style <> LastStyle then
    begin
      if LastStyle <> -1 then
      begin
        if Editor.StyleGetBold(LastStyle) and not Editor.StyleGetBold(Style) then
          FBuilder.Append('\b0');
        if Editor.StyleGetItalic(LastStyle) and not Editor.StyleGetItalic(Style) then
          FBuilder.Append('\i0');
        if Editor.StyleGetUnderline(LastStyle) and not Editor.StyleGetUnderline(Style) then
          FBuilder.Append('\ul0');
      end;
      if (LastStyle = -1) or (StyleFontIndex[Style] <> StyleFontIndex[LastStyle]) then
        FBuilder.AppendFormat('\f%d', [StyleFontIndex[Style]]);
      if (LastStyle = -1) or (Editor.StyleGetSize(Style) <> Editor.StyleGetSize(LastStyle)) then
        FBuilder.AppendFormat('\fs%d', [Editor.StyleGetSize(Style) * 2]);
      if (StyleColorBgIndex[Style] <> -1) and ((LastStyle = -1) or
        (Editor.StyleGetBack(Style) <> Editor.StyleGetBack(LastStyle))) then
      begin
        FBuilder.AppendFormat('\highlight%d',
          [StyleColorBgIndex[Style]]);
      end;
      FBuilder.AppendFormat('\cf%d',
          [StyleColorFgIndex[Style]]);
      if Editor.StyleGetBold(Style) and ((LastStyle = -1) or not Editor.StyleGetBold(LastStyle)) then
        FBuilder.Append('\b');
      if Editor.StyleGetItalic(Style) and ((LastStyle = -1) or not Editor.StyleGetItalic(LastStyle)) then
        FBuilder.Append('\i');
      if Editor.StyleGetUnderline(Style) and ((LastStyle = -1) or not Editor.StyleGetUnderline(LastStyle)) then
        FBuilder.Append('\ul');
      FBuilder.Append(' ');
      LastStyle := Style;
    end;
    case Ch of
      #0:;
      #10, #13:
      begin
        if (Ch = #13) and (I < DocLen - 1) and
          (Char(Editor.GetCharAt(I + 1)) = #10) then
          Inc(I);
        FBuilder.AppendLine('\par ');
      end;
      '\': FBuilder.Append('\\');
      '{': FBuilder.Append('\{');
      '}': FBuilder.Append('\}');
    else
      if C > $7F then
      begin	//this may be some UTF-8 character, so parse it as such
        UC  := C;
        C2 := Editor.GetCharAt(I + 1);
        if (C < $E0) then
        begin
          if (C2 and $C0) = $80 then
          begin
            Inc(I);
            UC := (($1F and C) shl 6);
            UC := UC or ($3F and C2);
          end;
        end
        else
        begin
          Inc(I);
          C3 := Editor.GetCharAt(I + 1);
          if ((C2 and $C0) = $80) and ((C3 and $C0) = $80) then
          begin
            Inc(I);
            UC := (($0F and C) shl 12);
            UC := UC or (($3F and C2) shl 6);
            UC := UC or  ($3F and C3);
          end;
        end;
        FBuilder.AppendFormat('\u%u?', [UC]);
      end
      else
      begin
        FBuilder.Append(Ch);
      end;
    end;
    Inc(I);
  end;
  if LastStyle <> -1 then
  begin
    if Editor.StyleGetBold(LastStyle) then
      FBuilder.Append('\b0');
    if Editor.StyleGetItalic(LastStyle) then
      FBuilder.Append('\i0');
    if Editor.StyleGetUnderline(LastStyle) then
      FBuilder.Append('\ul0');
    FBuilder.Append('\par ');
  end;
  FBuilder.AppendLine;
  FBuilder.AppendLine('}');
end;

function TExporterRTF.GetDefaultFilter: string;
begin
  Result := 'Rich Text Format (*.rtf)|*.rtf';
end;

procedure TExporterRTF.SaveToStream(Stream: TStream; Encoding: TEncoding);
var
  Buffer, Preamble: TBytes;
begin
  if Encoding = nil then
    Encoding := TEncoding.Default;
  Buffer := Encoding.GetBytes(FBuilder.ToString);
  Preamble := Encoding.GetPreamble;
  if Length(Preamble) > 0 then
    Stream.WriteBuffer(Preamble[0], Length(Preamble));
  Stream.WriteBuffer(Buffer[0], Length(Buffer));
end;

end.

